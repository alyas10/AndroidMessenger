<resources>
    <string name="app_name">Криптография</string>
    <!-- to toggle the open close button of the navigation drawer -->
    <string name="nav_open">Open</string>
    <string name="nav_close">Close</string>
    <string name="cezar1">" Шифр Цезаря является одним из наиболее простых и известных методов шифрования текстовых сообщений.
        Этот шифр был назван в честь римского императора Гая Юлия Цезаря, который, считается, использовал его для обмена сообщениями с военными командирами.
        Шифр Цезаря основан на простом принципе замены символов в сообщении с помощью сдвига алфавита.
    </string>
    <string name="cezar2">" Принцип работы шифра Цезаря очень прост: каждая буква алфавита заменяется другой буквой на фиксированное количество позиций в алфавите.
        Это число позиций называется ключом шифра. Например, если ключ шифра равен 3, каждая буква будет заменена буквой, следующей через две позиции в алфавите.
        Таким образом, буква "А" станет "Г", "Б" станет "Д", "В" станет "Е" и так далее."
    </string>
    <string name="cezar3">" Простота шифра Цезаря делает его доступным и понятным даже для начинающих.
        Однако, этот шифр является очень легким для взлома, особенно при использовании компьютерных программ или аналитических методов.
        Так как алфавит состоит из ограниченного числа символов, существует всего 26 вариантов ключей шифра.
        Это означает, что злоумышленник может просто перебрать все возможные варианты и расшифровать сообщение."

    </string>
    <string name="cezar4">" Не смотря на свою простоту и низкую степень защиты, шифр Цезаря все еще используется в различных областях, особенно в обучении шифрованию и для игровых целей.
        Он может быть интересным историческим примером шифрования и стимулировать интерес к изучению более сложных методов шифрования.
    </string>

    <string name="cezar11">" В заключение, шифр Цезаря является простым историческим шифром, основанным на принципе сдвига алфавита.
        Он применялся в древности и по сей день используется в обучении шифрованию и для игровых целей.
        Несмотря на свою простоту, он обладает низкой степенью защиты и может быть легко взломан.
        Однако, шифр Цезаря остается интересным примером исторического шифрования и вводит в мир шифров и криптографии."
    </string>
    <string name="cezar6">"1. Подготовка:

        а)  Определите алфавит: Выберите алфавит, который будет использоваться для шифрования. Это может быть русский, английский, еврейский алфавит или любой другой.
        б)  Найдите длину алфавита: Подсчитайте количество букв в выбранном алфавите.
        в)  Выберите ключ: Ключ - это число, которое определяет сдвиг букв в алфавите."
    </string>
    <string name="cezar7">"2. Шифрование:

    а)  Пронумеруйте буквы: Присвойте каждой букве алфавита порядковый номер, начиная с 1.
    б)  Замена букв: Для каждой буквы в сообщении:
    в)  Найдите номер этой буквы в алфавите.
    г)  Сложите номер буквы с ключом.
    д)  Если полученное число больше длины алфавита, вычтите из него длину алфавита.
    е)  Найдите букву в алфавите с полученным номером.
    ж)  Замените исходную букву в сообщении на найденную букву.string>
    </string>

    <string name="cezar8">" 3. Расшифрование:

    а)  Повторите шаги 1 и 2.
    б)  Для каждой зашифрованной буквы:
    в)  Найдите номер этой буквы в алфавите.
    г)  Вычтите ключ из номера буквы.
    д)  Если полученное число меньше 1, добавьте к нему длину алфавита.
    е)  Найдите букву в алфавите с полученным номером.
    ж)  Замените зашифрованную букву в сообщении на найденную букву.
    </string>

    <string name="cezar9">"Исходное сообщение: \"Привет\"

    Алфавит: Русский алфавит (33 буквы), нумерация  с А = 1.

    Ключ: 3

    Шифрование:

    П (17) -> Т (17 + 3 = 20)
    р (18) -> у (18 + 3 = 21)
    и (10) -> л (10 + 3 = 13)
    в (3) -> е (3 + 3 = 6)
    е (6) -> з (6 + 3 = 9)
    т (20) -> х (20 + 3 = 23)

    </string>

    <string name="cezar10">"

    Зашифрованное сообщение: \"Тулезх\"

    Расшифрование:

    Т (20) -> П (20 - 3 = 17)
    у (21) -> р (21 - 3 = 18)
    л (13) -> и (13 - 3 = 10)
    е (6) -> в (6 - 3 = 3)
    з (9) -> е (9 - 3 = 6)
    х (23) -> т (23 - 3 = 20)

    Расшифрованное сообщение: \"Привет\"
    </string>
    <string name="cezar">"
    </string>



    <string name="vigener">"
        Шифр Виженера был назван в честь ученого по имени Блез де Виженера, хотя на самом деле изобретательство этого шифра принадлежит Джовану Баттисте Белласо. Виженер разработал более совершенную версию шифра с использованием автоключа.

        Шифр Виженера представляет собой метод шифрования текста, использующий несколько шифров Цезаря, которые зависят от букв ключевого слова. Этот метод является формой полиалфавитной замены, где каждая буква исходного текста шифруется разными символами в зависимости от ключа.

        История шифра Виженера началась давно. Впервые о полиалфавитном шифре стало известно благодаря Леону Баттисте Альберти в 1467 году. Он использовал металлический диск для смены алфавитов. Йоханнес Тритемиус внес вклад, создав прямую таблицу для шифрации, важную основу для шифра Виженера. Позднее Джован Баттиста Белласо описал свою версию шифра Виженера в 1553 году. Этот шифр использовал повторяющийся ключ для изменения алфавитов.

        Однако настоящий мощный шифр с автоключом был опубликован в 1586 году Блезом де Виженером, хотя ошибочно та же методика была приписана ему в 19 веке. Шифр Виженера казался непреодолимым для новичков, и поэтому получил прозвище "неразборчивый шифр". Шифр нередко пытались сломать, и хотя он был взломан, ему присуща репутация крайне надежного способа шифрования.

        Этот метод шифрования вызывает интерес исследователей, и до сих пор использовался в различных областях знаний. Различные способы криптоанализа помогли взломать шифр Виженера, дав возможность понять его устройство и уязвимости.

        Алгоритм работы шифра Виженера:

        1. Подготовка:

    а)  Определите алфавит: Выберите алфавит, который будет использоваться для шифрования. Это может быть русский, английский, еврейский алфавит или любой другой.
    б)  Найдите длину алфавита: Подсчитайте количество букв в выбранном алфавите.
    в)  Выберите ключ: Ключ - это слово или фраза, которая будет использоваться для шифрования.

        2. Шифрование:

    а)  Пронумеруйте буквы: Присвойте каждой букве алфавита порядковый номер, начиная с 1.
    б)  Преобразуйте ключ: Преобразуйте буквы ключа в числа, используя их порядковые номера в алфавите.
    в)  Замена букв: Для каждой буквы в сообщении:
    г)  Найдите номер этой буквы в алфавите.
    д)  Найдите номер следующей буквы ключа.
    е)  Сложите номер буквы с номером ключа.
    ж)  Если полученное число больше длины алфавита, вычтите из него длину алфавита.
    з)  Найдите букву в алфавите с полученным номером.
    и)  Замените исходную букву в сообщении на найденную букву.
    л)  Перейдите к следующей букве ключа.

        3. Расшифрование:

    а)  Повторите шаги 1 и 2.
    б)  Для каждой зашифрованной буквы:
    в)  Найдите номер этой буквы в алфавите.
    г)  Найдите номер следующей буквы ключа.
    д)  Вычтите номер ключа из номера буквы.
    е)  Если полученное число меньше 1, добавьте к нему длину алфавита.
    ж)  Найдите букву в алфавите с полученным номером.
    з)  Замените зашифрованную букву в сообщении на найденную букву.
    и)  Перейдите к следующей букве ключа.

    Пример использования:

    Исходное сообщение: \"Привет, мир!\"

    Алфавит: Русский алфавит (33 буквы), где нумерация индексов букв в алфавите начинается с А = 1.

    Ключ: \"ключ\"

    Шифрование:

    П (17) + к (12) = Ы (29)
    р (18) + л (13) = э (31)
    и (10) + ю (32) - (33) = з (9)
    в (3) + ч (25) = ъ (28)
    е (6) + к (12) = р (18)
    т (20) + л (13) = я (33)
    , (,) -> , (,)
    м (14) + ю (32) - (33) = л (13)
    и (10) + ч (25) - (33) = б (2)
    р (18) + к (12) = ь (30)
    ! (!) -> ! (!)

    Зашифрованное сообщение: \"Ыэзъря, лбь!\"

    Расшифрование:

    Ы (29) - к (12) = П (17)
    э (31) - л (13) = р (18)
    з (9) + (33) - ю (32) = и (10)
    ъ (28) - ч (25) = в (3)
    р (18) - к (12) = е (6)
    я (33) - л (13) = т (20)
    , (,) -> , (,)
    л (13) + (33) - ю (32) = м (14)
    б (2) + (33) - ч (25) = и (10)
    ь (30) - к (12) = р (18)
    ! (!) -> ! (!)

    Расшифрованное сообщение: \"Привет, мир!\"

    </string>

    <string name="atbash">"
        Шифр Атбаш представляет собой античный метод шифрования, который, несмотря на свою простоту, остается весьма эффективным. Его происхождение часто ассоциируется с ивритским алфавитом, но точное историческое начало неизвестно.

        Основной принцип шифра Атбаш – замена каждой буквы на противоположную конечную букву в алфавите. Например, в латинском алфавите A заменяется на Z, B на Y и так далее. Этот метод основан на простой перестановке символов и не требует сложных вычислений.

        Шифр Атбаш использовался в различных культурах и периодах для шифрования текстов. В его основе лежит принцип замены, что делает его привлекательным для простых криптографических решений. Однако, несмотря на свою простоту, шифр обеспечивает базовый уровень безопасности, так как для его разгадки необходимо знание правила перестановки.

        Разгадать шифр Атбаш довольно просто, если известно правило его работы. Это делает его менее надежным для современного использования, особенно в контексте сложных криптографических задач. Вместе с тем, он может служить отличным учебным материалом для введения в принципы шифрования.

        В современных условиях шифр Атбаш может использоваться в образовательных целях, чтобы демонстрировать основные принципы шифрования. Также его можно встретить в головоломках и заданиях, требующих базового понимания криптографических концепций.

        Алгоритм работы шифра Атбаш:

        1. Подготовка:

    a)  Определите алфавит: Выберите алфавит, который будет использоваться для шифрования. Это может быть русский, английский, еврейский алфавит или любой другой.
    б)  Найдите длину алфавита: Подсчитайте количество букв в выбранном алфавите.

        2. Шифрование:

    а)  Пронумеруйте буквы: Присвойте каждой букве алфавита порядковый номер, начиная с 1.
    б)  Замена букв: Для каждой буквы в сообщении:
    в)  Найдите номер этой буквы в алфавите.
    г)  Вычтите номер буквы из длины алфавита.
    д)  Добавьте 1 к полученному значению.
    е)  Найдите букву в алфавите с полученным номером.
    ж)  Замените исходную букву в сообщении на найденную букву.

        3. Расшифрование:

    а)  Повторите шаги 1 и 2. Для каждой зашифрованной буквы:
    б)  Найдите номер этой буквы в алфавите.
    в)  Вычтите 1 из номера буквы.
    г)  Добавьте к полученному значению длину алфавита.
    д)  Найдите букву в алфавите с полученным номером.
    е)  Замените зашифрованную букву в сообщении на найденную букву.

    Пример использования:

    Исходное сообщение: \"Привет, мир!\"

    Алфавит: Русский алфавит (33 буквы), где нумерация индексов букв в алфавите начинается с А = 1.

    Шифрование:

    П (17) -> П (33 - 17 + 1 = 17)
    р (18) -> о (33 - 18 + 1 = 16)
    и (10) -> ц (33 - 10 + 1 = 24)
    в (3) -> э (33 - 3 + 1 = 31)
    е (6) -> ъ (33 - 6 + 1 = 28)
    т (20) -> м (33 - 20 + 1 = 14)
    , (,) -> , (,)
    м (14) -> т (33 - 14 + 1 = 20)
    и (10) -> ц (33 - 10 + 1 = 24)
    р (18) -> о (33 - 18 + 1 = 16)
    ! (!) -> ! (!)

    Зашифрованное сообщение: \"Поцэъм, тцо!\"

    Расшифрование:

    П (17) -> П (17 - 1 + 33 = 17)
    о (16) -> р (16 - 1 + 33 = 18)
    ц (24) -> и (24 - 1 + 33 = 10)
    э (31) -> в (31 - 1 + 33 = 3)
    ъ (28) -> е (28 - 1 + 33 = 6)
    м (14) -> т (14 - 1 + 33 = 20)
    , (,) -> , (,)
    т (21) -> м (20 - 1 + 33 = 14)
    ц (24) -> и (24 - 1 + 33 = 10)
    о (16) -> р (16 - 1 + 33 = 18)
    ! (!) -> ! (!)

    Расшифрованное сообщение: \"Привет, мир!\"

   </string>
    <string name="afin">"
        Аффинный шифр — это частный случай моноалфавитного шифра подстановки. В нем каждой букве алфавита ставится в соответствие число, затем при помощи модульной арифметики вычисляется новое число, которое заменяет старое в шифротексте. Основной принцип работы заключается в математической функции, где модуль — размер алфавита, а пара чисел — ключ шифра. Значения должны быть взаимно простыми.

        В основе аффинного шифра лежит теорема о шифровании с помощью аффинных преобразований: для любого алфавита и любых взаимно простых целых чисел a и b существует обратимое шифрование, то есть зашифрованное сообщение можно расшифровать.

        Создатель аффинного шифра неизвестен, но его использование ограничено из-за слабых криптографических свойств. В современном мире аффинный шифр редко применяется из-за своей уязвимости к атакам. Однако аналогичные принципы используются в других областях, например, в линейных конгруэнтных методах генерации псевдослучайных чисел

        Основной принцип работы аффинного шифра заключается в использовании двух чисел, которые служат ключами шифра. Первый ключ, обычно обозначаемый как a, используется для умножения, а второй ключ, обычно обозначаемый как b, используется для сложения. Формула для шифрования выглядит следующим образом:

        E(x)=(ax+b)modm, где

        x - это символ открытого текста, m - размер алфавита.

        Разгадывание аффинного шифра включает в себя аналитические и переборные методы. Аналитический подход требует анализа частотности букв и решения системы уравнений для восстановления ключей шифрования. Переборный метод заключается в проверке всех возможных комбинаций ключей до тех пор, пока не будет найдено правильное решение. Оба метода имеют свои ограничения: аналитический метод требует знания алфавита и зашифрованного текста, а переборный метод может быть неэффективным при большом объеме текста.

        Для упрощения процесса разгадывания существуют специализированные программы и онлайн-сервисы. Программы, такие как Crypt-OTP-2.00, и веб-сайты, например, dcode.fr, предлагают инструменты для автоматизации разгадывания шифров. Опытные программисты могут создавать собственные скрипты для этих целей. Несмотря на это, аффинный шифр часто используется в образовательных целях и головоломках, чтобы продемонстрировать основы криптографии.

        Аффинный шифр, хотя и не является стойким к современным методам криптоанализа, все еще применяется в учебных и исторических контекстах. Для более надежной защиты информации рекомендуется использовать современные шифры, такие как AES, RSA и Blowfish, а также криптографические библиотеки и фреймворки, предоставляющие разнообразные алгоритмы шифрования.

        Пример использования:

        Исходное сообщение: \"Привет, мир!\"

        Алфавит: Русский алфавит (33 буквы), где нумерация индексов букв в алфавите начинается с А = 1.

        Шифрование:

        Пусть функция шифрования будет f(x) = (ax + b) mod m, где:

        a = ключ a,

        b = ключ b,

        m = размер алфавита (в данном случае 33),

        x = позиция буквы в алфавите.

        Допустим, ключи a = 3 и b = 4. Тогда шифрование будет выглядеть следующим образом:
        П (17) -> Ч (f(17) = (3*17 + 4) mod 33 = 19)
        р (18) -> Ш (f(18) = (3*18 + 4) mod 33 = 22)
        и (10) -> Л (f(10) = (3*10 + 4) mod 33 = 4)
        в (3)  -> Г (f(3) = (3*3 + 4) mod 33 = 13)
        е (6)  -> К (f(6) = (3*6 + 4) mod 33 = 22)
        т (20) -> Э (f(20) = (3*20 + 4) mod 33 = 28)
        , (,)  -> , (,)
        м (14) -> Ц (f(14) = (3*14 + 4) mod 33 = 8)
        и (10) -> Л (f(10) = (3*10 + 4) mod 33 = 4)
        р (18) -> Ш (f(18) = (3*18 + 4) mod 33 = 22)
        ! (!)  -> ! (!)

        Зашифрованное сообщение: "Чшлгкэ, цлш!"

        Расшифрование:

        Пусть функция расшифрования будет f^{-1}(y) = a^{-1}(y - b) mod m, где:

        y = зашифрованная позиция буквы,

        a^{-1} = обратное к a по модулю m.

        Для нахождения a^{-1}, используем расширенный алгоритм Евклида.

        Предположим, что a^{-1} = 11 (так как 3*11 mod 33 = 1).

        Теперь расшифровка будет выглядеть так:
        Ч (19) -> П (f^{-1}(19) = 11*(19 - 4) mod 33 = 17)
        Ш (22) -> р (f^{-1}(22) = 11*(22 - 4) mod 33 = 18)
        Л (4)  -> и (f^{-1}(4) = 11*(4 - 4) mod 33 = 10)
        Г (13) -> в (f^{-1}(13) = 11*(13 - 4) mod 33 = 3)
        К (22) -> е (f^{-1}(22) = 11*(22 - 4) mod 33 = 6)
        Э (28) -> т (f^{-1}(28) = 11*(28 - 4) mod 33 = 20)
        , (,)  -> , (,)
        Ц (8)  -> м (f^{-1}(8) = 11*(8 - 4) mod 33 = 14)
        Л (4)  -> и (f^{-1}(4) = 11*(4 - 4) mod 33 = 10)
        Ш (22) -> р (f^{-1}(22) = 11*(22 - 4) mod 33 = 18)
        ! (!)  -> ! (!)

        Расшифрованное сообщение: \"Привет, мир!"\"
    </string>

    <string name="gamma">"
        Шифр гаммирования XOR, также известный как шифр Вернама, представляет собой симметричный метод шифрования, в котором для преобразования открытого текста в зашифрованный текст используется случайная последовательность битов, называемая гаммой.

        Гамма в криптографии обладает тремя ключевыми свойствами. Во-первых, она должна быть случайной последовательностью битов, что означает, что ее невозможно предсказать. Во-вторых, длина гаммы должна быть не меньше длины открытого текста, чтобы обеспечить полное покрытие и защиту информации. Наконец, гамма должна храниться в секрете от всех, кроме отправителя и получателя сообщения, чтобы обеспечить безопасность передачи данных.

        Процесс шифрования с использованием гаммы начинается с представления открытого текста в виде последовательности битов. Затем выбирается случайная гамма такой же длины, как и открытый текст. Далее к каждому биту открытого текста и соответствующему биту гаммы применяется поразрядная операция исключающего ИЛИ (XOR). Полученная последовательность битов является зашифрованным текстом. Этот метод обеспечивает высокий уровень безопасности, так как без знания гаммы расшифровать сообщение практически невозможно.

        Шифр XOR, обладающий теоретической стойкостью к вскрытию, основывается на трех ключевых принципах. Во-первых, гамма должна быть случайной последовательностью битов, что делает ее непредсказуемой. Во-вторых, гамма должна оставаться в секрете от всех, кроме отправителя и получателя сообщения, обеспечивая таким образом конфиденциальность передачи данных. Наконец, длина гаммы должна быть не меньше длины открытого текста, чтобы гарантировать полное покрытие и защиту информации. Эти принципы вместе обеспечивают высокую стойкость шифра XOR к атакам.

        Шифр XOR используется в различных областях, где необходимо обеспечить конфиденциальность информации. Он применялся в устаревших протоколах шифрования Wi-Fi, таких как WEP, и может использоваться в виртуальных частных сетях (VPN) для защиты конфиденциальности интернет-трафика. Кроме того, шифр XOR применяется в военных системах связи для защиты конфиденциальных данных.

        Несмотря на преимущества шифра XOR, в настоящее время для защиты конфиденциальной информации чаще используются более стойкие и современные шифры. Например, шифры AES и RSA, которые обеспечивают более высокий уровень безопасности и стойкости к криптоанализу.

        Допустим, у нас есть исходное сообщение “Привет, мир!” и мы используем русский алфавит (33 буквы), где нумерация индексов букв в алфавите начинается с А = 1.

        Шифрование:

        Мы определяем функцию шифрования как f(x)=(ax+b)modm
        , где:
        a = ключ a,
        b = ключ b,
        m = размер алфавита (в данном случае 33),
        x = позиция буквы в алфавите.

        Предположим, что ключи a = 3 и b = 4. Тогда шифрование будет выглядеть следующим образом:
        П (17) -> Ч (f(17) = (3*17 + 4) mod 33 = 19)
        р (18) -> Ш (f(18) = (3*18 + 4) mod 33 = 22)
        и (10) -> Л (f(10) = (3*10 + 4) mod 33 = 4)
        в (3)  -> Г (f(3) = (3*3 + 4) mod 33 = 13)
        е (6)  -> К (f(6) = (3*6 + 4) mod 33 = 22)
        т (20) -> Э (f(20) = (3*20 + 4) mod 33 = 28)
        , (,)  -> , (,)
        м (14) -> Ц (f(14) = (3*14 + 4) mod 33 = 8)
        и (10) -> Л (f(10) = (3*10 + 4) mod 33 = 4)
        р (18) -> Ш (f(18) = (3*18 + 4) mod 33 = 22)
        ! (!)  -> ! (!)

        Зашифрованное сообщение: “Чшлгкэ, цлш!”

        Дешифрование:

        Мы определяем функцию дешифрования как f−1(y)=a−1(y−b)modm
        , где:
        y = зашифрованная позиция буквы,

        Ч (19) -> П (f^{-1}(19) = 11*(19 - 4) mod 33 = 17)
        Ш (22) -> р (f^{-1}(22) = 11*(22 - 4) mod 33 = 18)
        Л (4)  -> и (f^{-1}(4) = 11*(4 - 4) mod 33 = 10)
        Г (13) -> в (f^{-1}(13) = 11*(13 - 4) mod 33 = 3)
        К (22) -> е (f^{-1}(22) = 11*(22 - 4) mod 33 = 6)
        Э (28) -> т (f^{-1}(28) = 11*(28 - 4) mod 33 = 20)
        , (,)  -> , (,)
        Ц (8)  -> м (f^{-1}(8) = 11*(8 - 4) mod 33 = 14)
        Л (4)  -> и (f^{-1}(4) = 11*(4 - 4) mod 33 = 10)
        Ш (22) -> р (f^{-1}(22) = 11*(22 - 4) mod 33 = 18)
        ! (!)  -> ! (!)

        Таким образом, расшифрованное сообщение: “Привет, мир!”.

    </string>

    <string name="rsa">"RSA (Rivest-Shamir-Adleman) - это алгоритм, используемый современными компьютерами для шифрования и дешифрования сообщений1. Это асимметричный криптографический алгоритм1. Асимметричность означает, что используются два разных ключа1. Это также называется криптографией с открытым ключом, потому что один из ключей может быть предоставлен любому1.

        Основной принцип работы шифра В системе RSA пользователь тайно выбирает и публикует открытый ключ, основанный на двух больших простых числах, вместе с вспомогательным значением1. Простые числа хранятся в секрете1. Сообщения могут быть зашифрованы любым человеком с помощью открытого ключа, но могут быть расшифрованы только тем, кто знает закрытый ключ1.

        Разгадка шифра Безопасность RSA основана на практической сложности факторизации произведения двух больших простых чисел, известной как "проблема факторизации"1. Взлом шифрования RSA известен как проблема RSA1. Нет опубликованных методов для победы над системой, если используется достаточно большой ключ1.

        Шифр RSA обладает теоретической стойкостью к вскрытию при соблюдении следующих условий: гамма должна быть случайной последовательностью битов и храниться в секрете от всех, кроме отправителя и получателя сообщения, а её длина должна быть не меньше длины открытого текста. Однако, стоит отметить, что шифр RSA уязвим к атакам с использованием известного открытого текста. Кроме того, на практике сложно обеспечить идеальную случайность и секретность гаммы, что может снижать стойкость шифра.

        Шифр RSA, простой в реализации и не требующий сложных математических вычислений, является ценным инструментом в современной криптографии. Его надежность обеспечивается использованием достаточно длинной и случайной гаммы, что позволяет достичь стойкости к вскрытию, сопоставимой с идеальной шифровальной системой. Конфиденциальность передаваемых данных гарантируется секретностью гаммы, используемой в шифре RSA.

        Давайте применим метод шифрования RSA к вашему сообщению “Привет, мир!” с использованием русского алфавита (33 буквы), где нумерация индексов букв в алфавите начинается с А = 1.

        Шифрование RSA основано на использовании пары ключей: открытого (e, n) и закрытого (d, n), где n - произведение двух простых чисел p и q, e - открытая экспонента (взаимно простое число с (p-1)(q-1)), а d - это число, удовлетворяющее условию (e*d) mod ((p-1)(q-1)) = 1.

        Функция шифрования определяется как f(x)=xemodn

        , где x - позиция буквы в алфавите.

        Предположим, что p = 3, q = 11, n = p*q = 33, e = 3. Тогда шифрование будет выглядеть следующим образом:

        П (17) -> Ч (f(17)=173mod33=19)
        р (18) -> Ш (f(18)=183mod33=22)
        и (10) -> Л (f(10)=103mod33=4)
        в (3)  -> Г (f(3)=33mod33=13)
        е (6)  -> К (f(6)=63mod33=22)
        т (20) -> Э (f(20)=203mod33=28)
        , (,)  -> , (,)
        м (14) -> Ц (f(14)=143mod33=8)
        и (10) -> Л (f(10)=103mod33=4)
        р (18) -> Ш (f(18)=183mod33=22)
        ! (!)  -> ! (!)

        Зашифрованное сообщение: “Чшлгкэ, цлш!”

        Дешифрование:

        Функция дешифрования определяется как f−1(y)=ydmodn

        , где y - зашифрованная позиция буквы.

        Предположим, что d = 7 (так как (3*7) mod ((3-1)(11-1)) = 1).

        Ч (19) -> П (f−1(19)=197mod33=17)
        Ш (22) -> р (f−1(22)=227mod33=18)
        Л (4)  -> и (f−1(4)=47mod33=10)
        Г (13) -> в (f−1(13)=137mod33=3)
        К (22) -> е (f−1(22)=227mod33=6)
        Э (28) -> т (f−1(28)=287mod33=20)
        , (,)  -> , (,)
        Ц (8)  -> м (f−1(8)=87mod33=14)
        Л (4)  -> и (f−1(4)=47mod33=10)
        Ш (22) -> р (f−1(22)=227mod33=18)
        ! (!)  -> ! (!)

        Таким образом, расшифрованное сообщение: “Привет, мир!”.

    </string>

    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string-array name="cipher_array">
        <item>Шифр Атбаш</item>
        <item>Шифр Цезаря</item>
        <item>Шифр Виженера</item>
        <item>Аффинный шифр</item>
        <item>Шифр RSA</item>
        <item>Шифр гаммирования (XOR)</item>
    </string-array>
    <string name="Welcome">"Добро пожаловать в HackProof Academy! Для старта перейдите в боковое меню.</string>
</resources>